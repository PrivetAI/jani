generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [
    vector(map: "vector")
  ]
}

enum UserTier {
  free
  plus
  pro
  ultra
}

enum UserStatus {
  active
  banned
  deleted
}

enum UserRole {
  user
  admin
  creator
}

enum SessionType {
  miniapp
  bot
  admin
}

enum EntitlementScope {
  subscription
  pack
  item
}

model User {
  id           String        @id @default(cuid())
  telegramId   BigInt?       @unique
  username     String?
  firstName    String?
  lastName     String?
  locale       String?
  tier         UserTier      @default(free)
  status       UserStatus    @default(active)
  roles        UserRole[]    @default([user])
  dailyQuota   Int           @default(50)
  dailyUsed    Int           @default(0)
  quotaResetAt DateTime      @default(now())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  lastActiveAt DateTime      @default(now())

  dialogs       Dialog[]
  messages      Message[]
  subscriptions Subscription[]
  transactions  Transaction[]
  inventory     UserInventory[]
  sessions      UserSession[]
  entitlements  UserEntitlement[]
  limits        UserLimit[]

  @@index([telegramId])
  @@index([tier])
  @@map("users")
}

enum CharacterVisibility {
  public
  premium
  creator
}

enum CharacterStatus {
  draft
  live
  archived
}

model Character {
  id              String              @id @default(cuid())
  slug            String              @unique
  name            String
  tagline         String?
  description     String
  avatarUrl       String?
  tags            String[]            @default([])
  visibility      CharacterVisibility @default(public)
  status          CharacterStatus     @default(draft)
  activeVersionId String?
  activeVersion   CharacterVersion?   @relation("ActiveVersion", fields: [activeVersionId], references: [id])
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  versions CharacterVersion[] @relation("CharacterVersions")
  dialogs  Dialog[]
  stories  Story[]

  @@index([status, visibility])
  @@map("characters")
}

model CharacterVersion {
  id          String      @id @default(cuid())
  characterId String
  version     Int         @default(1)
  persona     String
  greeting    String?
  temperature Float       @default(0.8)
  maxTokens   Int         @default(500)
  notes       String?
  createdAt   DateTime    @default(now())

  character Character  @relation("CharacterVersions", fields: [characterId], references: [id], onDelete: Cascade)
  activeFor Character? @relation("ActiveVersion")

  @@unique([characterId, version])
  @@map("character_versions")
}

enum DialogStatus {
  active
  archived
  deleted
}

model Dialog {
  id              String       @id @default(cuid())
  userId          String
  characterId     String
  storyId         String?
  currentNodeId   String?
  storyFlags      Json         @default("{}")
  summary         String?
  summaryUpdatedAt DateTime?
  status          DialogStatus @default(active)
  messageCount    Int          @default(0)
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  lastMessageAt   DateTime?

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  character Character @relation(fields: [characterId], references: [id])
  messages  Message[]
  story     Story?    @relation(fields: [storyId], references: [id])

  @@index([userId, status])
  @@index([characterId])
  @@map("dialogs")
}

enum MessageRole {
  user
  assistant
  system
}

model Message {
  id         String      @id @default(cuid())
  dialogId   String
  role       MessageRole
  content    String
  tokensUsed Int?
  latencyMs  Int?
  model      String?
  actions    Json?
  createdAt  DateTime    @default(now())
  userId     String

  dialog Dialog @relation(fields: [dialogId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id])

  @@index([dialogId, createdAt])
  @@map("messages")
}

model UserSession {
  id               String      @id @default(cuid())
  userId           String
  type             SessionType @default(miniapp)
  refreshTokenHash String
  ipAddress        String?
  userAgent        String?
  createdAt        DateTime    @default(now())
  expiresAt        DateTime
  revokedAt        DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_sessions")
}

model UserEntitlement {
  id        String           @id @default(cuid())
  userId    String
  scope     EntitlementScope
  slug      String
  title     String?
  expiresAt DateTime?
  metadata  Json?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, slug])
  @@index([scope, slug])
  @@map("user_entitlements")
}

model UserLimit {
  id          String   @id @default(cuid())
  userId      String
  channel     String   @default("default")
  dailyLimit  Int
  dailyUsed   Int      @default(0)
  softCap     Int      @default(2000)
  lastResetAt DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, channel])
  @@map("user_limits")
}

enum SubscriptionStatus {
  active
  cancelled
  expired
}

enum ItemCategory {
  consumable
  key
  booster
  cosmetic
  utility
}

enum TransactionType {
  subscription
  package
  item
}

enum TransactionStatus {
  pending
  completed
  failed
  refunded
}

model Subscription {
  id        String             @id @default(cuid())
  userId    String
  tier      UserTier
  status    SubscriptionStatus @default(active)
  priceStars Int
  startDate DateTime           @default(now())
  endDate   DateTime
  autoRenew Boolean            @default(true)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId, status])
  @@map("subscriptions")
}

model Transaction {
  id                      String            @id @default(cuid())
  userId                  String
  type                    TransactionType
  status                  TransactionStatus @default(pending)
  amountStars             Int
  telegramPaymentChargeId String?           @unique
  metadata                Json?
  source                  String            @default("telegram")
  refundedAt              DateTime?
  refundReason            String?
  createdAt               DateTime          @default(now())
  updatedAt               DateTime          @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId, status])
  @@index([telegramPaymentChargeId])
  @@map("transactions")
}

model Story {
  id          String    @id @default(cuid())
  characterId String
  slug        String
  title       String
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  character Character @relation(fields: [characterId], references: [id])
  dialogs   Dialog[]

  @@unique([characterId, slug])
  @@map("stories")
}

model Item {
  id          String       @id @default(cuid())
  slug        String       @unique
  name        String
  description String
  category    ItemCategory
  priceStars  Int
  effect      Json
  iconUrl     String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  inventory UserInventory[]

  @@map("items")
}

model UserInventory {
  id          String   @id @default(cuid())
  userId      String
  itemId      String
  quantity    Int      @default(1)
  isActive    Boolean  @default(false)
  activatedAt DateTime?
  expiresAt   DateTime?
  acquiredAt  DateTime  @default(now())

  user User @relation(fields: [userId], references: [id])
  item Item @relation(fields: [itemId], references: [id])

  @@unique([userId, itemId])
  @@index([userId, isActive])
  @@map("user_inventory")
}
